<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Inoki in KDE</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://kde.inoki.cc/"/>
  <updated>2019-05-27T06:58:21.835Z</updated>
  <id>http://kde.inoki.cc/</id>
  
  <author>
    <name>Weixuan XIAO (Inoki)</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>KDE Craft Packager on macOS</title>
    <link href="http://kde.inoki.cc/2019/05/26/Craft-packager/"/>
    <id>http://kde.inoki.cc/2019/05/26/Craft-packager/</id>
    <published>2019-05-26T21:57:22.000Z</published>
    <updated>2019-05-27T06:58:21.835Z</updated>
    
    <content type="html"><![CDATA[<p>In Craft, to create a package, we can use <code>craft --package &lt;blueprint-name&gt;</code> after the compiling and the installing of a library or an application with given blueprint name.</p><p>On macOS, <code>MacDMGPackager</code> is the packager used by Craft. The <code>MacDylibBundler</code>is used in <code>MacDMGPackager</code> to handle the dependencies.</p><p>In this article, I’ll give a brief introduction of the two classes and the improvement which I’ve done for my GSoC project.</p><h1 id="MacDMGPackager"><a href="#MacDMGPackager" class="headerlink" title="MacDMGPackager"></a>MacDMGPackager</h1><p><code>MacDMGPackager</code> is a subclass of <code>CollectionPackagerBase</code>. Its most important method is <code>createPackage</code>.</p><p>First of all, </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.internalCreatePackage(seperateSymbolFiles=packageSymbols)</span><br></pre></td></tr></table></figure><h2 id="Initialisation-of-directory-variables"><a href="#Initialisation-of-directory-variables" class="headerlink" title="Initialisation of directory variables"></a>Initialisation of directory variables</h2><p>Here we get the definitions, the path of the application which we want to pack, and the path of archive.<br>The <code>appPath</code> should be the root of an application package with <code>.app</code> extension name. According to the convention of applications on macOS, <code>targetLibdir</code> points to the library directory of the application.<br>During the compiling and the installing period, in the application directory, there is only a <code>.plist</code> and <code>MacOS</code> subdirectory. So next, the library directory is created for further using.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">defines = self.setDefaults(self.defines)</span><br><span class="line">appPath = self.getMacAppPath(defines)</span><br><span class="line">archive = os.path.normpath(self.archiveDir())</span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line">targetLibdir = os.path.join(appPath, <span class="string">"Contents"</span>, <span class="string">"Frameworks"</span>)</span><br><span class="line">utils.createDir(targetLibdir)</span><br></pre></td></tr></table></figure><h2 id="Moving-files-to-correct-directories"><a href="#Moving-files-to-correct-directories" class="headerlink" title="Moving files to correct directories"></a>Moving files to correct directories</h2><p>Then, we predefine a list of pairs of source and destination for directories and move the files to the destinations. The destionations are the correct directories of libraries, plugins and resources in a macOS application package.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">moveTargets = [</span><br><span class="line">    (os.path.join(archive, <span class="string">"lib"</span>, <span class="string">"plugins"</span>), os.path.join(appPath, <span class="string">"Contents"</span>, <span class="string">"PlugIns"</span>)),</span><br><span class="line">    (os.path.join(archive, <span class="string">"plugins"</span>), os.path.join(appPath, <span class="string">"Contents"</span>, <span class="string">"PlugIns"</span>)),</span><br><span class="line">    (os.path.join(archive, <span class="string">"lib"</span>), targetLibdir),</span><br><span class="line">    (os.path.join(archive, <span class="string">"share"</span>), os.path.join(appPath, <span class="string">"Contents"</span>, <span class="string">"Resources"</span>))]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> appPath.startswith(archive):</span><br><span class="line">    moveTargets += [(os.path.join(archive, <span class="string">"bin"</span>), os.path.join(appPath, <span class="string">"Contents"</span>, <span class="string">"MacOS"</span>))]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> src, dest <span class="keyword">in</span> moveTargets:</span><br><span class="line">    <span class="keyword">if</span> os.path.exists(src):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> utils.mergeTree(src, dest):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h2 id="Fixing-dependencies-using-MacDylibBundler"><a href="#Fixing-dependencies-using-MacDylibBundler" class="headerlink" title="Fixing dependencies using MacDylibBundler"></a>Fixing dependencies using MacDylibBundler</h2><p>After the moving, we create an instance of <code>MacDylibBundler</code> with <code>appPath</code>. After the <code>with</code> instruction, all the codes are executed with <code>DYLD_FALLBACK_LIBRARY_PATH=&lt;package.app&gt;/Contents/Frameworks:&lt;Craft-Root&gt;/lib</code> environment variable.</p><p>For further reading of this environment variable, please refer this question on <a href="https://stackoverflow.com/questions/3146274/is-it-ok-to-use-dyld-library-path-on-mac-os-x-and-whats-the-dynamic-library-s" target="_blank" rel="noopener">StackOverFlow</a>.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dylibbundler = MacDylibBundler(appPath)</span><br><span class="line"><span class="keyword">with</span> utils.ScopedEnv(&#123;<span class="string">'DYLD_FALLBACK_LIBRARY_PATH'</span>: targetLibdir + <span class="string">":"</span> + os.path.join(CraftStandardDirs.craftRoot(), <span class="string">"lib"</span>)&#125;):</span><br><span class="line">    <span class="comment"># ...</span></span><br></pre></td></tr></table></figure><h3 id="Fixing-dependencies-of-main-binary"><a href="#Fixing-dependencies-of-main-binary" class="headerlink" title="Fixing dependencies of main binary"></a>Fixing dependencies of main binary</h3><p>Here, we firstly create an object of Path. It points to the executable of macOS Package.</p><p>It should be reminded that, although here, we use the same name for both the macOS application package and the executable, it is not mandatory. The name of executable is defined by <code>CFBundleExecutable</code> in the <code>.plist</code> file. So maybe read it from the <code>.plist</code> file is a better solution.</p><p>Then, the method <code>bundleLibraryDependencies</code> is used to copy libraries and fix dependencies for the executable in the package.</p><p>A brief introduction of this method:</p><ol><li>Call <code>utils.getLibraryDeps</code> for getting a list of dependencies. This operation is done by using <code>otool -L</code>.</li><li>Copy missing dependencies into <code>Contents/Frameworks</code>, and update the library information in the executable.<br>I’ll give an analyse in detail in the next chapter.</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CraftCore.log.info(<span class="string">"Bundling main binary dependencies..."</span>)</span><br><span class="line">mainBinary = Path(appPath, <span class="string">"Contents"</span>, <span class="string">"MacOS"</span>, defines[<span class="string">'appname'</span>])</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> dylibbundler.bundleLibraryDependencies(mainBinary):</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h3 id="Fixing-dependencies-in-Frameworks-and-PlugIns"><a href="#Fixing-dependencies-in-Frameworks-and-PlugIns" class="headerlink" title="Fixing dependencies in Frameworks and PlugIns"></a>Fixing dependencies in Frameworks and PlugIns</h3><p>And then, we try to fix all the dependencies of libraries in <code>Contents/Frameworks</code> and <code>Contents/PlugIns</code>.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Fix up the library dependencies of files in Contents/Frameworks/</span></span><br><span class="line">CraftCore.log.info(<span class="string">"Bundling library dependencies..."</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> dylibbundler.fixupAndBundleLibsRecursively(<span class="string">"Contents/Frameworks"</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">CraftCore.log.info(<span class="string">"Bundling plugin dependencies..."</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> dylibbundler.fixupAndBundleLibsRecursively(<span class="string">"Contents/PlugIns"</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h3 id="Fixing-dependencies-using-macdeployqt"><a href="#Fixing-dependencies-using-macdeployqt" class="headerlink" title="Fixing dependencies using macdeployqt"></a>Fixing dependencies using macdeployqt</h3><p>The <code>macdeployqt</code> is used to fix the <code>Qt</code> libraries used by the application. <code>Craft</code> installed it while compiling and installing <code>Qt</code>. But don’t worry, it is not in your system path.</p><p>I have not yet found what <code>macdeployqt</code> exactly do, it’s nice to have an look at its source code.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> utils.system([<span class="string">"macdeployqt"</span>, appPath, <span class="string">"-always-overwrite"</span>, <span class="string">"-verbose=1"</span>]):</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h3 id="Removing-files-in-blacklist"><a href="#Removing-files-in-blacklist" class="headerlink" title="Removing files in blacklist"></a>Removing files in blacklist</h3><p>If <code>macdeplyqt</code> added some files which we don’t want, they would be removed here.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># macdeployqt might just have added some explicitly blacklisted files</span></span><br><span class="line">blackList = Path(self.packageDir(), <span class="string">"mac_blacklist.txt"</span>)</span><br><span class="line"><span class="keyword">if</span> blackList.exists():</span><br><span class="line">    pattern = [self.read_blacklist(str(blackList))]</span><br><span class="line">    <span class="comment"># use it as whitelist as we want only matches, ignore all others</span></span><br><span class="line">    matches = utils.filterDirectoryContent(appPath, whitelist=<span class="keyword">lambda</span> x, root: utils.regexFileFilter(x, root, pattern), blacklist=<span class="keyword">lambda</span> x, root:<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">for</span> f <span class="keyword">in</span> matches:</span><br><span class="line">        CraftCore.log.info(<span class="string">f"Remove blacklisted file: <span class="subst">&#123;f&#125;</span>"</span>)</span><br><span class="line">        utils.deleteFile(f)</span><br></pre></td></tr></table></figure><h3 id="Fixing-dependencies-after-fixing-of-macdeployqt"><a href="#Fixing-dependencies-after-fixing-of-macdeployqt" class="headerlink" title="Fixing dependencies after fixing of macdeployqt"></a>Fixing dependencies after fixing of macdeployqt</h3><p>After <code>macdeplotqt</code>, there may be some libraries or plugins added by <code>macdeplotqt</code>. So we do the fixing of dependencies once again.</p><p>But I’m doubting if we need to fix twice the dependencies. I’ll update this post after I figure out what will it lead to if we fust fix after <code>macdeployqt</code>.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># macdeployqt adds some more plugins so we fix the plugins after calling macdeployqt</span></span><br><span class="line">dylibbundler.checkedLibs = set()  <span class="comment"># ensure we check all libs again (but</span></span><br><span class="line"><span class="comment"># we should not need to make any changes)</span></span><br><span class="line">CraftCore.log.info(<span class="string">"Fixing plugin dependencies after macdeployqt..."</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> dylibbundler.fixupAndBundleLibsRecursively(<span class="string">"Contents/PlugIns"</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">CraftCore.log.info(<span class="string">"Fixing library dependencies after macdeployqt..."</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> dylibbundler.fixupAndBundleLibsRecursively(<span class="string">"Contents/Frameworks"</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h3 id="Checking-dependencies"><a href="#Checking-dependencies" class="headerlink" title="Checking dependencies"></a>Checking dependencies</h3><p>Then, we use <code>MacDylibBundler</code> to check all dependencies in the application package. If there is any bad dependency, the package process will fail.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Finally sanity check that we don't depend on absolute paths from the builder</span></span><br><span class="line">CraftCore.log.info(<span class="string">"Checking for absolute library paths in package..."</span>)</span><br><span class="line">found_bad_dylib = <span class="literal">False</span>  <span class="comment"># Don't exit immeditately so that we log all the bad libraries before failing:</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> dylibbundler.areLibraryDepsOkay(mainBinary):</span><br><span class="line">    found_bad_dylib = <span class="literal">True</span></span><br><span class="line">    CraftCore.log.error(<span class="string">"Found bad library dependency in main binary %s"</span>, mainBinary)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> dylibbundler.checkLibraryDepsRecursively(<span class="string">"Contents/Frameworks"</span>):</span><br><span class="line">    CraftCore.log.error(<span class="string">"Found bad library dependency in bundled libraries"</span>)</span><br><span class="line">    found_bad_dylib = <span class="literal">True</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> dylibbundler.checkLibraryDepsRecursively(<span class="string">"Contents/PlugIns"</span>):</span><br><span class="line">    CraftCore.log.error(<span class="string">"Found bad library dependency in bundled plugins"</span>)</span><br><span class="line">    found_bad_dylib = <span class="literal">True</span></span><br><span class="line"><span class="keyword">if</span> found_bad_dylib:</span><br><span class="line">    CraftCore.log.error(<span class="string">"Cannot not create .dmg since the .app contains a bad library depenency!"</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h2 id="Creating-DMG-image"><a href="#Creating-DMG-image" class="headerlink" title="Creating DMG image"></a>Creating DMG image</h2><p>Up to now, everything is well, we can create a DMG image for the application.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">name = self.binaryArchiveName(fileType=<span class="string">""</span>, includeRevision=<span class="literal">True</span>)</span><br><span class="line">dmgDest = os.path.join(self.packageDestinationDir(), <span class="string">f"<span class="subst">&#123;name&#125;</span>.dmg"</span>)</span><br><span class="line"><span class="keyword">if</span> os.path.exists(dmgDest):</span><br><span class="line">    utils.deleteFile(dmgDest)</span><br><span class="line">appName = defines[<span class="string">'appname'</span>] + <span class="string">".app"</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> utils.system([<span class="string">"create-dmg"</span>, <span class="string">"--volname"</span>, name,</span><br><span class="line">                        <span class="comment"># Add a drop link to /Applications:</span></span><br><span class="line">                        <span class="string">"--icon"</span>, appName, <span class="string">"140"</span>, <span class="string">"150"</span>, <span class="string">"--app-drop-link"</span>, <span class="string">"350"</span>, <span class="string">"150"</span>,</span><br><span class="line">                        dmgDest, appPath]):</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">CraftHash.createDigestFiles(dmgDest)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><p>An example of <code>DMG</code> image is like this one, users can drag the application into <code>Applications</code> directory to install it.</p><img src="/2019/05/26/Craft-packager/DMG-example.png" title="a DMG file"><h1 id="MacDylibBundler"><a href="#MacDylibBundler" class="headerlink" title="MacDylibBundler"></a>MacDylibBundler</h1><h2 id="Constructor"><a href="#Constructor" class="headerlink" title="Constructor"></a>Constructor</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, appPath: str)</span>:</span></span><br><span class="line">    <span class="comment"># Avoid processing the same file more than once</span></span><br><span class="line">    self.checkedLibs = set()</span><br><span class="line">    self.appPath = appPath</span><br></pre></td></tr></table></figure><p>In the constructor, a set is created to store the libraries which have been already checked. And the <code>appPath</code> passed by developer is stored.</p><h1 id="Methods"><a href="#Methods" class="headerlink" title="Methods"></a>Methods</h1><p>This method <code>bundleLibraryDependencies</code> and <code>_addLibToAppImage</code> are the most important methods in this class. But they’re too long. So I’ll only give some brief introduction of them.</p><p><code>_addLibToAppImage</code> checks whether a library is already in the <code>Contents/Frameworks</code>. If the library doesn’t exist, it copies it into the diretory and tries to fix it with some relative path.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_addLibToAppImage</span><span class="params">(self, libPath: Path)</span> -&gt; bool:</span></span><br><span class="line">    <span class="comment"># ...</span></span><br></pre></td></tr></table></figure><p><code>bundleLibraryDependencies</code> checks the dependencies of <code>fileToFix</code>. If there are some dependencies with absolute path, it copies the dependencies into <code>Contents/Frameworks</code> by calling <code>_addLibToAppImage</code>. And then, it calls <code>_updateLibraryReference</code> to update the reference of library.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bundleLibraryDependencies</span><span class="params">(self, fileToFix: Path)</span> -&gt; bool:</span></span><br><span class="line">    <span class="comment"># ...</span></span><br></pre></td></tr></table></figure><p>As description in the docstring, <code>fixupAndBundleLibsRecursively</code> can remove absolute references and budle all depedencies for all dylibs.</p><p>It traverses the directory, and for each file which is not symbol link, checks whether it ends with “.so” or “.dylib”, or there is “.so.” in the file name, or there is “.framework” in the full path and it’s a macOS binary. If it’s that case, call <code>bundleLibraryDependencies</code> method to bundle it in to <code>.app</code> package.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fixupAndBundleLibsRecursively</span><span class="params">(self, subdir: str)</span>:</span></span><br><span class="line">    <span class="string">"""Remove absolute references and budle all depedencies for all dylibs under :p subdir"""</span></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">    <span class="keyword">for</span> dirpath, dirs, files <span class="keyword">in</span> os.walk(os.path.join(self.appPath, subdir)):</span><br><span class="line">            <span class="keyword">for</span> filename <span class="keyword">in</span> files:</span><br><span class="line">                fullpath = Path(dirpath, filename)</span><br><span class="line">                <span class="keyword">if</span> fullpath.is_symlink():</span><br><span class="line">                    <span class="keyword">continue</span>  <span class="comment"># No need to update symlinks since we will process the target eventually.</span></span><br><span class="line">                <span class="keyword">if</span> (filename.endswith(<span class="string">".so"</span>)</span><br><span class="line">                        <span class="keyword">or</span> filename.endswith(<span class="string">".dylib"</span>)</span><br><span class="line">                        <span class="keyword">or</span> <span class="string">".so."</span> <span class="keyword">in</span> filename</span><br><span class="line">                        <span class="keyword">or</span> (<span class="string">f"<span class="subst">&#123;fullpath.name&#125;</span>.framework"</span> <span class="keyword">in</span> str(fullpath) <span class="keyword">and</span> utils.isBinary(str(fullpath)))):</span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">not</span> self.bundleLibraryDependencies(fullpath):</span><br><span class="line">                        CraftCore.log.info(<span class="string">"Failed to bundle dependencies for '%s'"</span>, os.path.join(dirpath, filename))</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="comment"># ...</span></span><br></pre></td></tr></table></figure><p><code>areLibraryDepsOkay</code> can detect all the dependencies. If the library is not in <code>@rpath</code>, <code>@executable_path</code> or system library path, the dependencies cannot be satisfied on every mac. It may work relevant to the environment. But it will be a big problem.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">areLibraryDepsOkay</span><span class="params">(self, fullPath: Path)</span>:</span></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">    <span class="keyword">for</span> dep <span class="keyword">in</span> utils.getLibraryDeps(str(fullPath)):</span><br><span class="line">        <span class="keyword">if</span> dep == libraryId <span class="keyword">and</span> <span class="keyword">not</span> os.path.isabs(libraryId):</span><br><span class="line">            <span class="keyword">continue</span>  <span class="comment"># non-absolute library id is fine</span></span><br><span class="line">        <span class="comment"># @rpath and @executable_path is fine</span></span><br><span class="line">        <span class="keyword">if</span> dep.startswith(<span class="string">"@rpath"</span>) <span class="keyword">or</span> dep.startswith(<span class="string">"@executable_path"</span>):</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="comment"># Also allow /System/Library/Frameworks/ and /usr/lib:</span></span><br><span class="line">        <span class="keyword">if</span> dep.startswith(<span class="string">"/usr/lib/"</span>) <span class="keyword">or</span> dep.startswith(<span class="string">"/System/Library/Frameworks/"</span>):</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> dep.startswith(CraftStandardDirs.craftRoot()):</span><br><span class="line">            CraftCore.log.error(<span class="string">"ERROR: %s references absolute library path from craftroot: %s"</span>, relativePath,</span><br><span class="line">                                dep)</span><br><span class="line">        <span class="keyword">elif</span> dep.startswith(<span class="string">"/"</span>):</span><br><span class="line">            CraftCore.log.error(<span class="string">"ERROR: %s references absolute library path: %s"</span>, relativePath, dep)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            CraftCore.log.error(<span class="string">"ERROR: %s has bad dependency: %s"</span>, relativePath, dep)</span><br><span class="line">        found_bad_lib = <span class="literal">True</span></span><br></pre></td></tr></table></figure><p>Here, in <code>checkLibraryDepsRecursively</code>, we traverse the directory to check all the dependencies of libraries, which is <code>.dylib</code> or <code>.so</code>.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">checkLibraryDepsRecursively</span><span class="params">(self, subdir: str)</span>:</span></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">    <span class="keyword">for</span> dirpath, dirs, files <span class="keyword">in</span> os.walk(os.path.join(self.appPath, subdir)):</span><br><span class="line">        <span class="keyword">for</span> filename <span class="keyword">in</span> files:</span><br><span class="line">            fullpath = Path(dirpath, filename)</span><br><span class="line">            <span class="keyword">if</span> fullpath.is_symlink() <span class="keyword">and</span> <span class="keyword">not</span> fullpath.exists():</span><br><span class="line">                CraftCore.log.error(<span class="string">"Found broken symlink '%s' (%s)"</span>, fullpath,</span><br><span class="line">                                    os.readlink(str(fullpath)))</span><br><span class="line">                foundError = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> filename.endswith(<span class="string">".so"</span>) <span class="keyword">or</span> filename.endswith(<span class="string">".dylib"</span>) <span class="keyword">or</span> <span class="string">".so."</span> <span class="keyword">in</span> filename:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> self.areLibraryDepsOkay(fullpath):</span><br><span class="line">                    CraftCore.log.error(<span class="string">"Found library dependency error in '%s'"</span>, fullpath)</span><br><span class="line">                    foundError = <span class="literal">True</span></span><br><span class="line">    <span class="comment"># ...</span></span><br></pre></td></tr></table></figure><h2 id="Static-methods-in-class"><a href="#Static-methods-in-class" class="headerlink" title="Static methods in class"></a>Static methods in class</h2><p>The <code>_updateLibraryReference</code> method can use <code>install_name_tool -change</code> command to change a reference of dynamic library in a macOS/BSD binary.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@staticmethod</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_updateLibraryReference</span><span class="params">(fileToFix: Path, oldRef: str, newRef: str = None)</span> -&gt; bool:</span></span><br><span class="line">    <span class="keyword">if</span> newRef <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        basename = os.path.basename(oldRef)</span><br><span class="line">        newRef = <span class="string">"@executable_path/../Frameworks/"</span> + basename</span><br><span class="line">    <span class="keyword">with</span> utils.makeWritable(fileToFix):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> utils.system([<span class="string">"install_name_tool"</span>, <span class="string">"-change"</span>, oldRef, newRef, str(fileToFix)], logCommand=<span class="literal">False</span>):</span><br><span class="line">            CraftCore.log.error(<span class="string">"%s: failed to update library dependency path from '%s' to '%s'"</span>,</span><br><span class="line">                                fileToFix, oldRef, newRef)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><p>The <code>_getLibraryNameId</code> method can use <code>otool -D</code> to get the identity of a dynamic library in a macOS/BSD binary.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@staticmethod</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_getLibraryNameId</span><span class="params">(fileToFix: Path)</span> -&gt; str:</span></span><br><span class="line">    libraryIdOutput = io.StringIO(</span><br><span class="line">        subprocess.check_output([<span class="string">"otool"</span>, <span class="string">"-D"</span>, str(fileToFix)]).decode(<span class="string">"utf-8"</span>).strip())</span><br><span class="line">    lines = libraryIdOutput.readlines()</span><br><span class="line">    <span class="keyword">if</span> len(lines) == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">    <span class="comment"># Should have exactly one line with the id now</span></span><br><span class="line">    <span class="keyword">assert</span> len(lines) == <span class="number">2</span>, lines</span><br><span class="line">    <span class="keyword">return</span> lines[<span class="number">1</span>].strip()</span><br></pre></td></tr></table></figure><p>The <code>_fixupLibraryId</code> method can use <code>install_name_tool -id</code> to try to fix the absolute identity of a dynamic library in a macOS/BSD binary.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@classmethod</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_fixupLibraryId</span><span class="params">(cls, fileToFix: Path)</span>:</span></span><br><span class="line">    libraryId = cls._getLibraryNameId(fileToFix)</span><br><span class="line">    <span class="keyword">if</span> libraryId <span class="keyword">and</span> os.path.isabs(libraryId):</span><br><span class="line">        CraftCore.log.debug(<span class="string">"Fixing library id name for %s"</span>, libraryId)</span><br><span class="line">        <span class="keyword">with</span> utils.makeWritable(fileToFix):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> utils.system([<span class="string">"install_name_tool"</span>, <span class="string">"-id"</span>, os.path.basename(libraryId), str(fileToFix)],</span><br><span class="line">                                logCommand=<span class="literal">False</span>):</span><br><span class="line">                CraftCore.log.error(<span class="string">"%s: failed to fix absolute library id name for"</span>, fileToFix)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="comment"># ...</span></span><br></pre></td></tr></table></figure><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>This class is a magic class which can achieve almost everything on macOS.</p><p>But the code style is a little confusing. And the parameters are not agreed. Some methods use <code>str</code> to represent a path, some use <code>Path</code>.</p><p>Maybe this can be also improved in the future.</p><p>Anyway, it’s really a helpful class.</p><h1 id="Improvement"><a href="#Improvement" class="headerlink" title="Improvement"></a>Improvement</h1><p>During my bonding period, I found that there is a library named <code>qca-qt5</code> is not fixed appropriately. It caused a crash.</p><h2 id="Locating-the-problem"><a href="#Locating-the-problem" class="headerlink" title="Locating the problem"></a>Locating the problem</h2><p>After analyzing of crash log, I found that the library <code>qca-qt5</code> is loaded twice. Two libraries with same dynamic library id caused this crash.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">qca-qt5 (0) &lt;14AD33D7-196F-32BB-91B6-598FA39EEF20&gt; /Volumes/*/kdeconnect-indicator.app/Contents/Frameworks/qca-qt5</span><br><span class="line">(??? - ???) &lt;14AD33D7-196F-32BB-91B6-598FA39EEF20&gt; /Users/USER/*/qca-qt5.framework/Versions/2.2.0/qca-qt5</span><br></pre></td></tr></table></figure></p><p>One is in the <code>.app</code> package, the other is in <code>CraftRoot/lib</code>.</p><img src="/2019/05/26/Craft-packager/Craft-lib.png" title="Craft/lib"><img src="/2019/05/26/Craft-packager/Frameworks-lib.png" title="Frameworks"><p>As far as I know, <code>qca-qt5</code> tried to search its plugins in some path. The one in the package is not fixed, so it started a searching of plugins in the <code>CraftRoot/lib</code> directory. The plugins in it refer the <code>qca-qt5</code> in the directory. So the two libraries with the same name are loaded, and the application crashed.</p><h2 id="Cause"><a href="#Cause" class="headerlink" title="Cause"></a>Cause</h2><p>With good knowing of <code>MacDylibBundler</code>, we can improve it to fix the bug. And this will be helpful to other applications or libraries in <code>Craft</code>.</p><p>I noticed that all the libraries with <code>.dylib</code> can be handled correctly. The problem is based on the libraries in the <code>.framework</code> package. It seems that <code>Craft</code> cannot handle the dynamic libraries in the <code>.framework</code> correctly.</p><p>And we can see that, in <code>checkLibraryDepsRecursively</code>, only <code>.so</code> and <code>.dylib</code> are checked. So this is a bug covered deeply.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CRAFT: ➜  MacOS otool -L kdeconnectd</span><br><span class="line">kdeconnectd:</span><br><span class="line">/Volumes/Storage/Inoki/CraftRoot/lib/libkdeconnectcore.1.dylib (compatibility version 1.0.0, current version 1.3.3)</span><br><span class="line">/Volumes/Storage/Inoki/CraftRoot/lib/libKF5KIOWidgets.5.dylib (compatibility version 5.0.0, current version 5.57.0)</span><br><span class="line">/Volumes/Storage/Inoki/CraftRoot/lib/libKF5Notifications.5.dylib (compatibility version 5.0.0, current version 5.57.0)</span><br><span class="line">/Volumes/Storage/Inoki/CraftRoot/lib/qca-qt5.framework Versions/2.2.0/qca-qt5 (compatibility version 2.0.0, current version 2.2.0)</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>In the <code>_addLibToAppImage</code> method, the library in the <code>framework</code> is copied directly to the <code>Contents/Frameworks</code>. For example, <code>lib/qca-qt5.framework/Versions/2.2.0/qca-qt5</code> becomes <code>Contents/Frameworks/qca-qt5</code>.</p><p>And then, during the fix in <code>fixupAndBundleLibsRecursively</code> method, according to the following code, it will not be fixed. Although it should be in a <code>.framework</code> directory and it’s a binary, after <code>_addLibToAppImage</code>, it will not be in a <code>.framework</code> directory. So it will not be fixed.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (filename.endswith(<span class="string">".so"</span>)</span><br><span class="line">        <span class="keyword">or</span> filename.endswith(<span class="string">".dylib"</span>)</span><br><span class="line">        <span class="keyword">or</span> <span class="string">".so."</span> <span class="keyword">in</span> filename</span><br><span class="line">        <span class="keyword">or</span> (<span class="string">f"<span class="subst">&#123;fullpath.name&#125;</span>.framework"</span> <span class="keyword">in</span> str(fullpath) <span class="keyword">and</span> utils.isBinary(str(fullpath)))):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> self.bundleLibraryDependencies(fullpath):</span><br><span class="line">        CraftCore.log.info(<span class="string">"Failed to bundle dependencies for '%s'"</span>, os.path.join(dirpath, filename))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure></p><h2 id="Fixing-it"><a href="#Fixing-it" class="headerlink" title="Fixing it !"></a>Fixing it !</h2><p>To fix it, I think a good idea is copying all the <code>.framework</code> directory and keeping its structure.</p><p>I firstly do a checking in the <code>_addLibToAppImage</code> method. For example, if <code>qca-qt5</code> is in the <code>qca-qt5.framework</code> subdirectory, we change the <code>libBasename</code> to <code>qca-qt5.framework/Versions/2.2.0/qca-qt5</code>. So the <code>targetPath</code> can also be updated correctly.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">libBasename = libPath.name</span><br><span class="line"></span><br><span class="line"><span class="comment"># Handle dylib in framework</span></span><br><span class="line"><span class="keyword">if</span> <span class="string">f"<span class="subst">&#123;libPath.name&#125;</span>.framework"</span> <span class="keyword">in</span> str(libPath):</span><br><span class="line">    libBasename = str(libPath)[str(libPath).find(<span class="string">f"<span class="subst">&#123;libPath.name&#125;</span>.framework"</span>):]</span><br><span class="line"></span><br><span class="line">targetPath = Path(self.appPath, <span class="string">"Contents/Frameworks/"</span>, libBasename)</span><br><span class="line"><span class="keyword">if</span> targetPath.exists() <span class="keyword">and</span> targetPath <span class="keyword">in</span> self.checkedLibs:</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><p>After several checkings, an important section is copying the library. I add some code to check if the library is in a <code>.framework</code> directory. If a library is in a <code>.framework</code> directory, I try to copy the entire directory to the <code>Contents/Frameworks</code>. So for <code>qca-qt5</code>, it should be <code>Contents/Frameworks/qca-qt5.framework/Versions/2.2.0/qca-qt5</code>.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> targetPath.exists():</span><br><span class="line">    <span class="keyword">if</span> <span class="string">f"<span class="subst">&#123;libPath.name&#125;</span>.framework"</span> <span class="keyword">in</span> str(libPath):</span><br><span class="line">        <span class="comment"># Copy the framework of dylib</span></span><br><span class="line">        frameworkPath = str(libPath)[:(str(libPath).find(<span class="string">".framework"</span>) + len(<span class="string">".framework"</span>))]</span><br><span class="line">        frameworkTargetPath = str(targetPath)[:(str(targetPath).find(<span class="string">".framework"</span>) + len(<span class="string">".framework"</span>))]</span><br><span class="line">        utils.copyDir(frameworkPath, frameworkTargetPath, linkOnly=<span class="literal">False</span>)</span><br><span class="line">        CraftCore.log.info(<span class="string">"Added library dependency '%s' to bundle -&gt; %s"</span>, frameworkPath, frameworkTargetPath)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        utils.copyFile(str(libPath), str(targetPath), linkOnly=<span class="literal">False</span>)</span><br><span class="line">        CraftCore.log.info(<span class="string">"Added library dependency '%s' to bundle -&gt; %s"</span>, libPath, targetPath)</span><br></pre></td></tr></table></figure><p>After copying, another important point is in <code>_updateLibraryReference</code>. If a library is in a <code>.framework</code> directory, the new reference should be <code>@executable_path/../Frameworks/*.framework/...</code>.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> newRef <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">    basename = os.path.basename(oldRef)</span><br><span class="line">    <span class="keyword">if</span> <span class="string">f"<span class="subst">&#123;basename&#125;</span>.framework"</span> <span class="keyword">in</span> oldRef:</span><br><span class="line">        <span class="comment"># Update dylib in framework</span></span><br><span class="line">        newRef = <span class="string">"@executable_path/../Frameworks/"</span> + oldRef[oldRef.find(<span class="string">f"<span class="subst">&#123;basename&#125;</span>.framework"</span>):]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        newRef = <span class="string">"@executable_path/../Frameworks/"</span> + basename</span><br></pre></td></tr></table></figure><p>After fixing, the executable can be launched without crash.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">CRAFT: ➜  MacOS otool -L kdeconnectd</span><br><span class="line">kdeconnectd:</span><br><span class="line">@executable_path/../Frameworks/libkdeconnectcore.1.dylib (compatibility version 1.0.0, current version 1.3.3)</span><br><span class="line">@executable_path/../Frameworks/libKF5KIOWidgets.5.dylib (compatibility version 5.0.0, current version 5.57.0)</span><br><span class="line">@executable_path/../Frameworks/libKF5Notifications.5.dylib (compatibility version 5.0.0, current version 5.57.0)</span><br><span class="line">@executable_path/../Frameworks/qca-qt5.framework/Versions/2.2.0/qca-qt5 (compatibility version 2.0.0, current version 2.2.0)</span><br><span class="line">    ...</span><br><span class="line">CRAFT: ➜  MacOS ./kdeconnectd</span><br><span class="line">kdeconnect.core: KdeConnect daemon starting</span><br><span class="line">kdeconnect.core: onStart</span><br><span class="line">kdeconnect.core: KdeConnect daemon started</span><br><span class="line">kdeconnect.core: Broadcasting identity packet</span><br></pre></td></tr></table></figure><h1 id="Conclusion-1"><a href="#Conclusion-1" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>In the software development, there are always some cases which we cannot consider. Open Source gives us the possibility of collecting intelligence from people all over the world to handle such cases.</p><p>That’s also why I like Open Source so much.</p><p>Today is the first day of coding period, I hope all goes well for the community and all GSoC students :)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;In Craft, to create a package, we can use &lt;code&gt;craft --package &amp;lt;blueprint-name&amp;gt;&lt;/code&gt; after the compiling and the installing of a
      
    
    </summary>
    
      <category term="Craft" scheme="http://kde.inoki.cc/categories/Craft/"/>
    
      <category term="Package" scheme="http://kde.inoki.cc/categories/Craft/Package/"/>
    
    
      <category term="Craft" scheme="http://kde.inoki.cc/tags/Craft/"/>
    
  </entry>
  
</feed>
